# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute the product of two matrix polynomials
NULL

polymul_matt <- function(amat, bmat) {
    .Call(`_sigex_polymul_matt`, amat, bmat)
}

#' computes autocovariances of VARMA
#'
#' Background:
#'    function computes autocovariances of VARMA (p,q) from lag zero
#'		to maxlag, with array inputs phi and theta.  VARMA equation:
#'  	(1 - phi[1]B ... - phi[p]B^p) X_t = (1 + theta[1]B ...+ theta[q]B^q) WN_t
#'
#' @param param: matrix of dimension m x (p+q+1)m, equals [ phi | theta | sigma ]
#'		  phi: block matrix of dimension m x mp of VAR coefficients
#'		  theta: block matrix of dimension m x mq of VMA coefficients
#'		  sigma: m x m covariance matrix of white noise
#' @param p - AR order
#' @param q - MA order
#' @param maxlag - final lag of autocovariance needed
#' @return autocovariances at lags 0 through maxlag, as array of dimension m x m x (maxlag+1)
#' @export
VARMA_auto <- function(param, p, q, maxlag) {
    .Call(`_sigex_VARMA_auto`, param, p, q, maxlag)
}

#' Eigenvalue decompostion
#'
#' Wrapper function for armadillo `eig_gen`.
#' Eigen decomposition of dense general (non-symmetric/non-hermitian) square matrix X
#'
#' @param X - square matrix
#' @return The eigenvalues and corresponding right eigenvectors are stored in
#'     eigval and eigvec, respectively
#' @export
getEigenValues <- function(M) {
    .Call(`_sigex_getEigenValues`, M)
}

#' complexExp - Documentation update needed
#'
#' @param x
#' @return z
#' @export
complexExp <- function(x) {
    .Call(`_sigex_complexExp`, x)
}

#' polymult - Documentation update needed
#'
#' @param a
#' @param b
#' @return product a * b
#' @export
polymult <- function(a, b) {
    .Call(`_sigex_polymult`, a, b)
}

#' polumul_mat - Documentation update needed
#'
#' @param amat
#' @param bmat
#' @return product amat(z) * bmat(z)
#' @export
polymul_mat <- function(amat, bmat) {
    .Call(`_sigex_polymul_mat`, amat, bmat)
}

#' ar_adjoint - Documentation update needed
#'
#' @param poly_array
#' @return list object ...
#' @export
ar_adjoint <- function(poly_array) {
    .Call(`_sigex_ar_adjoint`, poly_array)
}

#' computes autocovariances of SVARMA usng frequency domain
#'
#' Backgroud:
#'   function computes autocovariances of SVARMA (p,q,ps,qs) from lag zero
#'		to maxlag, with array inputs phi and theta.  SVARMA equation:
#'   (1 - phi[1]B ... - phi[p]B^p) (1 - Phi[1]B^s ... - Phi[ps]B^{s*ps}) X_t =
#'   (1 + theta[1]B ... + theta[q]B^q) (1 + Theta[1]B^s ... + Theta[qs]B^{s*qs}) WN_t.
#'
#' @param param - matrix of dimension m x (p+q+ps+qs+1), equals [ phi | theta | phiseas | thetaseas | sigma ]
#'		          phi: block matrix of dimension N x N*p of VAR coefficients
#'		          theta: block matrix of dimension N x N*q of VMA coefficients
#'             phiseas:  block matrix of dimension N x N*ps of SVAR coefficients
#'             thetaseas:  block matrix of dimension N x N*qs of SVMA coefficients
#'		          sigma: N x N covariance matrix of white noise
#' @param p - AR order
#' @param q - MA order
#' @param ps - seasonal AR order
#' @param qs - seasonal MA order
#' @param season - period (e.g. monthly = 12)
#' @param grid - Riemann mesh size
#' @param maxlag - maximum autocovariance lag needed
#' @return autocovariances at lags 0 through maxlag, as array of dimension m x m x (maxlag+1)
#' @export
auto_VARMA <- function(param, p, q, ps, qs, season, grid, maxlag) {
    .Call(`_sigex_auto_VARMA`, param, p, q, ps, qs, season, grid, maxlag)
}

